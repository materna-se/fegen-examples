// This file has been generated by FeGen based on a spring application. Do not edit it.

import {
    BaseClient, RequestAdapter, FetchAdapter,
    ApiHateoasObjectBase, ApiHateoasObjectReadMultiple, Items, PagedItems, ApiNavigationLinks,
    apiHelper, stringHelper, Dto, Entity, EntitySecurity, isEndpointCallAllowed
} from '@materna-se/fegen-runtime';
import { AddressNew, AddressDto, Address, ContactNew, ContactDto, Contact, IgnoredSearchEntityNew, IgnoredSearchEntityDto, IgnoredSearchEntity, PlainFieldTestEntityNew, PlainFieldTestEntityDto, PlainFieldTestEntity, PrimitiveTestEntityNew, PrimitiveTestEntityDto, PrimitiveTestEntity, RelTestEntityNew, RelTestEntityDto, RelTestEntity, SecuredEntityNew, SecuredEntityDto, SecuredEntity, UserNew, UserDto, User } from './Entities';
import {  } from './Entities';
import { AddressBaseProjection, ContactBaseProjection, ContactFull, FullRelTestEntity, IgnoredSearchEntityBaseProjection, NoRepoEntityBaseProjection, NotExportedTestEntityBaseProjection, PlainFieldTestEntityBaseProjection, PrimitiveTestEntityBaseProjection, RelTestEntityBaseProjection, SecuredEntityBaseProjection, UserBaseProjection } from './Entities';
import { CustomEndpointControllerClient } from './controller/CustomEndpointControllerClient';
import { TestRestControllerClient } from './controller/TestRestControllerClient';

export class ApiClient {
    public readonly addressClient: AddressClient;
    public readonly contactClient: ContactClient;
    public readonly ignoredSearchEntityClient: IgnoredSearchEntityClient;
    public readonly plainFieldTestEntityClient: PlainFieldTestEntityClient;
    public readonly primitiveTestEntityClient: PrimitiveTestEntityClient;
    public readonly relTestEntityClient: RelTestEntityClient;
    public readonly securedEntityClient: SecuredEntityClient;
    public readonly userClient: UserClient;
    public readonly customEndpointControllerClient: CustomEndpointControllerClient;
    public readonly testRestControllerClient: TestRestControllerClient;

    constructor(fetchAdapter?: FetchAdapter) {
        const requestAdapter = new RequestAdapter(fetchAdapter ?? new FetchAdapter());
        this.addressClient = new AddressClient(this, requestAdapter);
        this.contactClient = new ContactClient(this, requestAdapter);
        this.ignoredSearchEntityClient = new IgnoredSearchEntityClient(this, requestAdapter);
        this.plainFieldTestEntityClient = new PlainFieldTestEntityClient(this, requestAdapter);
        this.primitiveTestEntityClient = new PrimitiveTestEntityClient(this, requestAdapter);
        this.relTestEntityClient = new RelTestEntityClient(this, requestAdapter);
        this.securedEntityClient = new SecuredEntityClient(this, requestAdapter);
        this.userClient = new UserClient(this, requestAdapter);
        this.customEndpointControllerClient = new CustomEndpointControllerClient(requestAdapter);
        this.testRestControllerClient = new TestRestControllerClient(requestAdapter);
    }
}

export class AddressClient extends BaseClient<ApiClient, AddressNew, Address> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/contactAddresses", "addresses", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        
    }
  
    public static build(base: Partial<AddressNew> = {}): AddressNew {
        return {
            city: base.city !== undefined ? base.city : "",
            country: base.country !== undefined ? base.country : "",
            street: base.street !== undefined ? base.street : "",
            zip: base.zip !== undefined ? base.zip : ""
        }
    }
  
    protected toPlainObj(obj: Address): Address {
        return {
            id: obj.id,
            city: obj.city,
            country: obj.country,
            street: obj.street,
            zip: obj.zip,
            _links: obj._links
        };
    }
  
    public async readProjectionsAddressBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "city,ASC" | "city,DESC" | "street,ASC" | "street,DESC" | "zip,ASC" | "zip,DESC") : Promise<PagedItems<AddressBaseProjection>> {
        return this.readProjections<AddressBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionAddressBaseProjection(id: number): Promise<AddressBaseProjection| undefined> {
        return this.readProjection<AddressBaseProjection>(id, "baseProjection");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "city,ASC" | "city,DESC" | "street,ASC" | "street,DESC" | "zip,ASC" | "zip,DESC") : Promise<PagedItems<Address>> {
        return await this.readProjections<Address>(undefined, page, size, sort);
    }
  
    
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/contactAddresses");
    }

  
    
  
    
}

export class ContactClient extends BaseClient<ApiClient, ContactNew, Contact> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/contacts", "contacts", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        this.readAddressProjection = this.readAddressProjection.bind(this);
            this.readOwnerProjection = this.readOwnerProjection.bind(this);
    }
  
    public static build(base: Partial<ContactNew> = {}): ContactNew {
        return {
            firstName: base.firstName !== undefined ? base.firstName : "",
            lastName: base.lastName !== undefined ? base.lastName : "",
            number: base.number !== undefined ? base.number : "",
            address: base.address !== undefined ? base.address : null,
            owner: base.owner !== undefined ? base.owner : null
        }
    }
  
    protected toPlainObj(obj: Contact): Contact {
        return {
            id: obj.id,
            firstName: obj.firstName,
            lastName: obj.lastName,
            number: obj.number,
            _links: obj._links
        };
    }
  
    public async readProjectionsContactBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "firstName,ASC" | "firstName,DESC" | "lastName,ASC" | "lastName,DESC") : Promise<PagedItems<ContactBaseProjection>> {
        return this.readProjections<ContactBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionContactBaseProjection(id: number): Promise<ContactBaseProjection| undefined> {
        return this.readProjection<ContactBaseProjection>(id, "baseProjection");
    }
    

public async readProjectionsContactFull(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "firstName,ASC" | "firstName,DESC" | "lastName,ASC" | "lastName,DESC") : Promise<PagedItems<ContactFull>> {
        return this.readProjections<ContactFull>("full", page, size, sort);
    }
            
    public async readProjectionContactFull(id: number): Promise<ContactFull| undefined> {
        return this.readProjection<ContactFull>(id, "full");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "firstName,ASC" | "firstName,DESC" | "lastName,ASC" | "lastName,DESC") : Promise<PagedItems<Contact>> {
        return await this.readProjections<Contact>(undefined, page, size, sort);
    }
  
    public async deleteFromAddress(returnType: Contact, childToDelete: Address) {
        await this._requestAdapter.fetchAdapter.delete(`/api/contacts/${returnType.id}/address/${childToDelete.id}`);
    }
    
    public async deleteFromOwner(returnType: Contact, childToDelete: User) {
        await this._requestAdapter.fetchAdapter.delete(`/api/contacts/${returnType.id}/owner/${childToDelete.id}`);
    }
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/contacts");
    }

  
    public async readAddress(obj: ContactDto): Promise<Address | undefined> {
        return this.readAddressProjection<Address>(obj);
    }
    
    public async readAddressProjectionAddressBaseProjection(obj: ContactDto): Promise<AddressBaseProjection | undefined> {
        return this.readAddressProjection<AddressBaseProjection>(obj, "baseProjection");
    }
    
    public async readAddressProjection<T extends Dto>(obj: ContactDto, projection?: string): Promise<T | undefined> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.address);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return undefined; }
        if(!response.ok){ throw response; }
        
        const result = (await response.json()) as T;
        return apiHelper.injectIds(result);
    }
    
    public async setAddress(returnType: Contact, child: Address) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        // eslint-disable-next-line no-throw-literal
        if(!child._links) throw `Child has no _links: ${child.id}`;
        await this._requestAdapter.adaptAnyToOne(
            apiHelper.removeParamsFromNavigationHref(returnType._links.address),
            child._links.self.href
        );
    }
    
    public async readOwner(obj: ContactDto): Promise<User | undefined> {
        return this.readOwnerProjection<User>(obj);
    }
    
    public async readOwnerProjectionUserBaseProjection(obj: ContactDto): Promise<UserBaseProjection | undefined> {
        return this.readOwnerProjection<UserBaseProjection>(obj, "baseProjection");
    }
    
    public async readOwnerProjection<T extends Dto>(obj: ContactDto, projection?: string): Promise<T | undefined> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.owner);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return undefined; }
        if(!response.ok){ throw response; }
        
        const result = (await response.json()) as T;
        return apiHelper.injectIds(result);
    }
    
    public async setOwner(returnType: Contact, child: User) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        // eslint-disable-next-line no-throw-literal
        if(!child._links) throw `Child has no _links: ${child.id}`;
        await this._requestAdapter.adaptAnyToOne(
            apiHelper.removeParamsFromNavigationHref(returnType._links.owner),
            child._links.self.href
        );
    }
  
    public async searchFindByNameContaining<T extends Contact>(name: string, projection?: string, page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "firstName,ASC" | "firstName,DESC" | "lastName,ASC" | "lastName,DESC"): Promise<PagedItems<T>> {
        const parameters: {[key: string]: string | number | boolean | undefined} = {name};
        if (page !== undefined) {
            parameters["page"] = `${page}`;
        }
        if (size !== undefined) {
            parameters["size"] = `${size}`;
        }
            
        const url = stringHelper.appendParams("/api/contacts/search/findByNameContaining", parameters);
    
        const response = await this._requestAdapter.fetchAdapter.get(url);
        const responseObj = ((await response.json()) as ApiHateoasObjectReadMultiple<T[]>);
        
        const elements = ((responseObj._embedded && responseObj._embedded.contacts) || []).map(item => (apiHelper.injectIds(item)));

return {
    items: elements,
    _links: responseObj._links,
    page: responseObj.page
};
    }
    
    public async isSearchFindByNameContainingAllowed(): Promise<boolean> {
        return isEndpointCallAllowed(this._requestAdapter.fetchAdapter, "//api", "GET", "//api/contacts/search/findByNameContaining");
    }

public async searchFindByNames<T extends Contact>(firstName: string, lastName: string, projection?: string, sort?: "id,ASC" | "id,DESC" | "firstName,ASC" | "firstName,DESC" | "lastName,ASC" | "lastName,DESC"): Promise<T | undefined> {
    const parameters: {[key: string]: string | number | boolean | undefined} = {firstName, lastName};
        
    const url = stringHelper.appendParams("/api/contacts/search/findByNames", parameters);

    const response = await this._requestAdapter.fetchAdapter.get(url);
    const responseObj = ((await response.json()) as T);
    
    return responseObj;
}

public async isSearchFindByNamesAllowed(): Promise<boolean> {
    return isEndpointCallAllowed(this._requestAdapter.fetchAdapter, "//api", "GET", "//api/contacts/search/findByNames");
}

    public async searchContactsByRegex<T extends Contact>(nameRegex: string, projection?: string, sort?: "id,ASC" | "id,DESC" | "firstName,ASC" | "firstName,DESC" | "lastName,ASC" | "lastName,DESC"): Promise<Items<T>> {
        const parameters: {[key: string]: string | number | boolean | undefined} = {nameRegex};
            
        const url = stringHelper.appendParams("/api/search/contactsByRegex", parameters);
    
        const response = await this._requestAdapter.fetchAdapter.get(url);
        const responseObj = ((await response.json()) as ApiHateoasObjectBase<T[]>);
        
        const elements = ((responseObj._embedded && responseObj._embedded.contacts) || []).map(item => (apiHelper.injectIds(item)));

return {
    items: elements,
    _links: responseObj._links
};
    }
    
    public async isSearchContactsByRegexAllowed(): Promise<boolean> {
        return isEndpointCallAllowed(this._requestAdapter.fetchAdapter, "//api", "GET", "//api/search/contactsByRegex");
    }

    public async searchSecuredContactsByRegex<T extends Contact>(nameRegex: string, projection?: string, sort?: "id,ASC" | "id,DESC" | "firstName,ASC" | "firstName,DESC" | "lastName,ASC" | "lastName,DESC"): Promise<Items<T>> {
        const parameters: {[key: string]: string | number | boolean | undefined} = {nameRegex};
            
        const url = stringHelper.appendParams("/api/search/securedContactsByRegex", parameters);
    
        const response = await this._requestAdapter.fetchAdapter.get(url);
        const responseObj = ((await response.json()) as ApiHateoasObjectBase<T[]>);
        
        const elements = ((responseObj._embedded && responseObj._embedded.contacts) || []).map(item => (apiHelper.injectIds(item)));

return {
    items: elements,
    _links: responseObj._links
};
    }
    
    public async isSearchSecuredContactsByRegexAllowed(): Promise<boolean> {
        return isEndpointCallAllowed(this._requestAdapter.fetchAdapter, "//api", "GET", "//api/search/securedContactsByRegex");
    }
}

export class IgnoredSearchEntityClient extends BaseClient<ApiClient, IgnoredSearchEntityNew, IgnoredSearchEntity> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/ignoredSearchEntities", "ignoredSearchEntities", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        
    }
  
    public static build(base: Partial<IgnoredSearchEntityNew> = {}): IgnoredSearchEntityNew {
        return {
            text: base.text !== undefined ? base.text : ""
        }
    }
  
    protected toPlainObj(obj: IgnoredSearchEntity): IgnoredSearchEntity {
        return {
            id: obj.id,
            text: obj.text,
            _links: obj._links
        };
    }
  
    public async readProjectionsIgnoredSearchEntityBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "text,ASC" | "text,DESC") : Promise<PagedItems<IgnoredSearchEntityBaseProjection>> {
        return this.readProjections<IgnoredSearchEntityBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionIgnoredSearchEntityBaseProjection(id: number): Promise<IgnoredSearchEntityBaseProjection| undefined> {
        return this.readProjection<IgnoredSearchEntityBaseProjection>(id, "baseProjection");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "text,ASC" | "text,DESC") : Promise<PagedItems<IgnoredSearchEntity>> {
        return await this.readProjections<IgnoredSearchEntity>(undefined, page, size, sort);
    }
  
    
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/ignoredSearchEntities");
    }

  
    
  
    
}

export class PlainFieldTestEntityClient extends BaseClient<ApiClient, PlainFieldTestEntityNew, PlainFieldTestEntity> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/plainFieldTestEntities", "plainFieldTestEntities", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        
    }
  
    public static build(base: Partial<PlainFieldTestEntityNew> = {}): PlainFieldTestEntityNew {
        return {
            bothWithNotNullOnField: base.bothWithNotNullOnField !== undefined ? base.bothWithNotNullOnField : "",
            bothWithNotNullOnGetter: base.bothWithNotNullOnGetter !== undefined ? base.bothWithNotNullOnGetter : "",
            notNullField: base.notNullField !== undefined ? base.notNullField : "",
            nullableField: base.nullableField !== undefined ? base.nullableField : "",
            transientFieldWithGetter: base.transientFieldWithGetter !== undefined ? base.transientFieldWithGetter : ""
        }
    }
  
    protected toPlainObj(obj: PlainFieldTestEntity): PlainFieldTestEntity {
        return {
            id: obj.id,
            bothWithNotNullOnField: obj.bothWithNotNullOnField,
            bothWithNotNullOnGetter: obj.bothWithNotNullOnGetter,
            notNullField: obj.notNullField,
            nullableField: obj.nullableField,
            transientFieldWithGetter: obj.transientFieldWithGetter,
            _links: obj._links
        };
    }
  
    public async readProjectionsPlainFieldTestEntityBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "bothWithNotNullOnField,ASC" | "bothWithNotNullOnField,DESC" | "bothWithNotNullOnGetter,ASC" | "bothWithNotNullOnGetter,DESC" | "notNullField,ASC" | "notNullField,DESC" | "transientFieldWithGetter,ASC" | "transientFieldWithGetter,DESC") : Promise<PagedItems<PlainFieldTestEntityBaseProjection>> {
        return this.readProjections<PlainFieldTestEntityBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionPlainFieldTestEntityBaseProjection(id: number): Promise<PlainFieldTestEntityBaseProjection| undefined> {
        return this.readProjection<PlainFieldTestEntityBaseProjection>(id, "baseProjection");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "bothWithNotNullOnField,ASC" | "bothWithNotNullOnField,DESC" | "bothWithNotNullOnGetter,ASC" | "bothWithNotNullOnGetter,DESC" | "notNullField,ASC" | "notNullField,DESC" | "transientFieldWithGetter,ASC" | "transientFieldWithGetter,DESC") : Promise<PagedItems<PlainFieldTestEntity>> {
        return await this.readProjections<PlainFieldTestEntity>(undefined, page, size, sort);
    }
  
    
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/plainFieldTestEntities");
    }

  
    
  
    
}

export class PrimitiveTestEntityClient extends BaseClient<ApiClient, PrimitiveTestEntityNew, PrimitiveTestEntity> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/primitiveTestEntities", "primitiveTestEntities", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        
    }
  
    public static build(base: Partial<PrimitiveTestEntityNew> = {}): PrimitiveTestEntityNew {
        return {
            booleanTrue: base.booleanTrue !== undefined ? base.booleanTrue : false,
            date2000_6_12: base.date2000_6_12 !== undefined ? base.date2000_6_12 : "1970-01-01",
            dateTime2000_1_1_12_30: base.dateTime2000_1_1_12_30 !== undefined ? base.dateTime2000_1_1_12_30 : "1970-01-01T00:00:00",
            int32: base.int32 !== undefined ? base.int32 : 0,
            intMinusBillion: base.intMinusBillion !== undefined ? base.intMinusBillion : 0,
            long64: base.long64 !== undefined ? base.long64 : 0,
            optionalIntBillion: base.optionalIntBillion !== undefined ? base.optionalIntBillion : 0,
            optionalIntNull: base.optionalIntNull !== undefined ? base.optionalIntNull : 0,
            stringText: base.stringText !== undefined ? base.stringText : ""
        }
    }
  
    protected toPlainObj(obj: PrimitiveTestEntity): PrimitiveTestEntity {
        return {
            id: obj.id,
            booleanTrue: obj.booleanTrue,
            date2000_6_12: obj.date2000_6_12,
            dateTime2000_1_1_12_30: obj.dateTime2000_1_1_12_30,
            int32: obj.int32,
            intMinusBillion: obj.intMinusBillion,
            long64: obj.long64,
            optionalIntBillion: obj.optionalIntBillion,
            optionalIntNull: obj.optionalIntNull,
            stringText: obj.stringText,
            _links: obj._links
        };
    }
  
    public async readProjectionsPrimitiveTestEntityBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "booleanTrue,ASC" | "booleanTrue,DESC" | "date2000_6_12,ASC" | "date2000_6_12,DESC" | "int32,ASC" | "int32,DESC" | "intMinusBillion,ASC" | "intMinusBillion,DESC" | "long64,ASC" | "long64,DESC" | "stringText,ASC" | "stringText,DESC") : Promise<PagedItems<PrimitiveTestEntityBaseProjection>> {
        return this.readProjections<PrimitiveTestEntityBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionPrimitiveTestEntityBaseProjection(id: number): Promise<PrimitiveTestEntityBaseProjection| undefined> {
        return this.readProjection<PrimitiveTestEntityBaseProjection>(id, "baseProjection");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "booleanTrue,ASC" | "booleanTrue,DESC" | "date2000_6_12,ASC" | "date2000_6_12,DESC" | "int32,ASC" | "int32,DESC" | "intMinusBillion,ASC" | "intMinusBillion,DESC" | "long64,ASC" | "long64,DESC" | "stringText,ASC" | "stringText,DESC") : Promise<PagedItems<PrimitiveTestEntity>> {
        return await this.readProjections<PrimitiveTestEntity>(undefined, page, size, sort);
    }
  
    
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/primitiveTestEntities");
    }

  
    
  
    public async searchFindByInt32<T extends PrimitiveTestEntity>(intValue: number, projection?: string, sort?: "id,ASC" | "id,DESC" | "booleanTrue,ASC" | "booleanTrue,DESC" | "date2000_6_12,ASC" | "date2000_6_12,DESC" | "int32,ASC" | "int32,DESC" | "intMinusBillion,ASC" | "intMinusBillion,DESC" | "long64,ASC" | "long64,DESC" | "stringText,ASC" | "stringText,DESC"): Promise<Items<T>> {
        const parameters: {[key: string]: string | number | boolean | undefined} = {intValue};
            
        const url = stringHelper.appendParams("/api/primitiveTestEntities/search/findByInt32", parameters);
    
        const response = await this._requestAdapter.fetchAdapter.get(url);
        const responseObj = ((await response.json()) as ApiHateoasObjectBase<T[]>);
        
        const elements = ((responseObj._embedded && responseObj._embedded.primitiveTestEntities) || []).map(item => (apiHelper.injectIds(item)));

return {
    items: elements,
    _links: responseObj._links
};
    }
    
    public async isSearchFindByInt32Allowed(): Promise<boolean> {
        return isEndpointCallAllowed(this._requestAdapter.fetchAdapter, "//api", "GET", "//api/primitiveTestEntities/search/findByInt32");
    }
}

export class RelTestEntityClient extends BaseClient<ApiClient, RelTestEntityNew, RelTestEntity> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/relTestEntities", "relTestEntities", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        this.readManyToManyProjection = this.readManyToManyProjection.bind(this);
            this.readManyToOneOptionalProjection = this.readManyToOneOptionalProjection.bind(this);
            this.readManyToOneRequiredProjection = this.readManyToOneRequiredProjection.bind(this);
            this.readOneToManyProjection = this.readOneToManyProjection.bind(this);
            this.readOneToOneOptionalProjection = this.readOneToOneOptionalProjection.bind(this);
            this.readOneToOneRequiredProjection = this.readOneToOneRequiredProjection.bind(this);
    }
  
    public static build(base: Partial<RelTestEntityNew> & {manyToOneRequired: User,oneToOneRequired: User}): RelTestEntityNew {
        return {
            testString: base.testString !== undefined ? base.testString : "",
            embedded: base.embedded !== undefined ? base.embedded : null,
            embeddedNullable: base.embeddedNullable !== undefined ? base.embeddedNullable : null,
            manyToMany: base.manyToMany !== undefined ? base.manyToMany : [],
            manyToOneOptional: base.manyToOneOptional !== undefined ? base.manyToOneOptional : null,
            manyToOneRequired: base.manyToOneRequired,
            oneToMany: base.oneToMany !== undefined ? base.oneToMany : [],
            oneToOneOptional: base.oneToOneOptional !== undefined ? base.oneToOneOptional : null,
            oneToOneRequired: base.oneToOneRequired
        }
    }
  
    protected toPlainObj(obj: RelTestEntity): RelTestEntity {
        return {
            id: obj.id,
            testString: obj.testString,
            embedded: obj.embedded,
            embeddedNullable: obj.embeddedNullable,
            _links: obj._links
        };
    }
  
    public async readProjectionsFullRelTestEntity(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "testString,ASC" | "testString,DESC") : Promise<PagedItems<FullRelTestEntity>> {
        return this.readProjections<FullRelTestEntity>("full", page, size, sort);
    }
            
    public async readProjectionFullRelTestEntity(id: number): Promise<FullRelTestEntity| undefined> {
        return this.readProjection<FullRelTestEntity>(id, "full");
    }
    

public async readProjectionsRelTestEntityBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "testString,ASC" | "testString,DESC") : Promise<PagedItems<RelTestEntityBaseProjection>> {
        return this.readProjections<RelTestEntityBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionRelTestEntityBaseProjection(id: number): Promise<RelTestEntityBaseProjection| undefined> {
        return this.readProjection<RelTestEntityBaseProjection>(id, "baseProjection");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "testString,ASC" | "testString,DESC") : Promise<PagedItems<RelTestEntity>> {
        return await this.readProjections<RelTestEntity>(undefined, page, size, sort);
    }
  
    public async deleteFromManyToMany(returnType: RelTestEntity, childToDelete: User) {
        await this._requestAdapter.fetchAdapter.delete(`/api/relTestEntities/${returnType.id}/manyToMany/${childToDelete.id}`);
    }
    
    public async deleteFromManyToOneOptional(returnType: RelTestEntity, childToDelete: User) {
        await this._requestAdapter.fetchAdapter.delete(`/api/relTestEntities/${returnType.id}/manyToOneOptional/${childToDelete.id}`);
    }
    
    public async deleteFromManyToOneRequired(returnType: RelTestEntity, childToDelete: User) {
        await this._requestAdapter.fetchAdapter.delete(`/api/relTestEntities/${returnType.id}/manyToOneRequired/${childToDelete.id}`);
    }
    
    public async deleteFromOneToMany(returnType: RelTestEntity, childToDelete: User) {
        await this._requestAdapter.fetchAdapter.delete(`/api/relTestEntities/${returnType.id}/oneToMany/${childToDelete.id}`);
    }
    
    public async deleteFromOneToOneOptional(returnType: RelTestEntity, childToDelete: User) {
        await this._requestAdapter.fetchAdapter.delete(`/api/relTestEntities/${returnType.id}/oneToOneOptional/${childToDelete.id}`);
    }
    
    public async deleteFromOneToOneRequired(returnType: RelTestEntity, childToDelete: User) {
        await this._requestAdapter.fetchAdapter.delete(`/api/relTestEntities/${returnType.id}/oneToOneRequired/${childToDelete.id}`);
    }
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/relTestEntities");
    }

  
    public async readManyToMany(obj: RelTestEntityDto): Promise<User[]> {
        return this.readManyToManyProjection<User>(obj);
    }
    
    public async readManyToManyProjectionUserBaseProjection(obj: RelTestEntityDto): Promise<UserBaseProjection[]> {
        return this.readManyToManyProjection<UserBaseProjection>(obj, "baseProjection");
    }
    
    public async readManyToManyProjection<T extends Dto>(obj: RelTestEntityDto, projection?: string): Promise<T[]> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.manyToMany);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return []; }
        if(!response.ok){ throw response; }
        return (((await response.json()) as ApiHateoasObjectBase<T[]>)._embedded.users).map(item => (apiHelper.injectIds(item)));
    }
    
    public async setManyToMany(returnType: RelTestEntity, children: User[]) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        await this._requestAdapter.adaptAnyToMany(
            apiHelper.removeParamsFromNavigationHref(returnType._links.manyToMany),
            children.map(c => {
                // eslint-disable-next-line no-throw-literal
                if(!c._links) throw `Child has no _links: ${c.id}`;
                return c._links.self.href;
            })
        )
    }
    
    public async addToManyToMany(returnType: RelTestEntity, childToAdd: User) {
        await this._requestAdapter.addToObj(childToAdd, returnType, "manyToMany");
    }
    
    public async readManyToOneOptional(obj: RelTestEntityDto): Promise<User | undefined> {
        return this.readManyToOneOptionalProjection<User>(obj);
    }
    
    public async readManyToOneOptionalProjectionUserBaseProjection(obj: RelTestEntityDto): Promise<UserBaseProjection | undefined> {
        return this.readManyToOneOptionalProjection<UserBaseProjection>(obj, "baseProjection");
    }
    
    public async readManyToOneOptionalProjection<T extends Dto>(obj: RelTestEntityDto, projection?: string): Promise<T | undefined> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.manyToOneOptional);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return undefined; }
        if(!response.ok){ throw response; }
        
        const result = (await response.json()) as T;
        return apiHelper.injectIds(result);
    }
    
    public async setManyToOneOptional(returnType: RelTestEntity, child: User) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        // eslint-disable-next-line no-throw-literal
        if(!child._links) throw `Child has no _links: ${child.id}`;
        await this._requestAdapter.adaptAnyToOne(
            apiHelper.removeParamsFromNavigationHref(returnType._links.manyToOneOptional),
            child._links.self.href
        );
    }
    
    public async readManyToOneRequired(obj: RelTestEntityDto): Promise<User | undefined> {
        return this.readManyToOneRequiredProjection<User>(obj);
    }
    
    public async readManyToOneRequiredProjectionUserBaseProjection(obj: RelTestEntityDto): Promise<UserBaseProjection | undefined> {
        return this.readManyToOneRequiredProjection<UserBaseProjection>(obj, "baseProjection");
    }
    
    public async readManyToOneRequiredProjection<T extends Dto>(obj: RelTestEntityDto, projection?: string): Promise<T | undefined> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.manyToOneRequired);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return undefined; }
        if(!response.ok){ throw response; }
        
        const result = (await response.json()) as T;
        return apiHelper.injectIds(result);
    }
    
    public async setManyToOneRequired(returnType: RelTestEntity, child: User) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        // eslint-disable-next-line no-throw-literal
        if(!child._links) throw `Child has no _links: ${child.id}`;
        await this._requestAdapter.adaptAnyToOne(
            apiHelper.removeParamsFromNavigationHref(returnType._links.manyToOneRequired),
            child._links.self.href
        );
    }
    
    public async readOneToMany(obj: RelTestEntityDto): Promise<User[]> {
        return this.readOneToManyProjection<User>(obj);
    }
    
    public async readOneToManyProjectionUserBaseProjection(obj: RelTestEntityDto): Promise<UserBaseProjection[]> {
        return this.readOneToManyProjection<UserBaseProjection>(obj, "baseProjection");
    }
    
    public async readOneToManyProjection<T extends Dto>(obj: RelTestEntityDto, projection?: string): Promise<T[]> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.oneToMany);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return []; }
        if(!response.ok){ throw response; }
        return (((await response.json()) as ApiHateoasObjectBase<T[]>)._embedded.users).map(item => (apiHelper.injectIds(item)));
    }
    
    public async setOneToMany(returnType: RelTestEntity, children: User[]) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        await this._requestAdapter.adaptAnyToMany(
            apiHelper.removeParamsFromNavigationHref(returnType._links.oneToMany),
            children.map(c => {
                // eslint-disable-next-line no-throw-literal
                if(!c._links) throw `Child has no _links: ${c.id}`;
                return c._links.self.href;
            })
        )
    }
    
    public async addToOneToMany(returnType: RelTestEntity, childToAdd: User) {
        await this._requestAdapter.addToObj(childToAdd, returnType, "oneToMany");
    }
    
    public async readOneToOneOptional(obj: RelTestEntityDto): Promise<User | undefined> {
        return this.readOneToOneOptionalProjection<User>(obj);
    }
    
    public async readOneToOneOptionalProjectionUserBaseProjection(obj: RelTestEntityDto): Promise<UserBaseProjection | undefined> {
        return this.readOneToOneOptionalProjection<UserBaseProjection>(obj, "baseProjection");
    }
    
    public async readOneToOneOptionalProjection<T extends Dto>(obj: RelTestEntityDto, projection?: string): Promise<T | undefined> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.oneToOneOptional);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return undefined; }
        if(!response.ok){ throw response; }
        
        const result = (await response.json()) as T;
        return apiHelper.injectIds(result);
    }
    
    public async setOneToOneOptional(returnType: RelTestEntity, child: User) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        // eslint-disable-next-line no-throw-literal
        if(!child._links) throw `Child has no _links: ${child.id}`;
        await this._requestAdapter.adaptAnyToOne(
            apiHelper.removeParamsFromNavigationHref(returnType._links.oneToOneOptional),
            child._links.self.href
        );
    }
    
    public async readOneToOneRequired(obj: RelTestEntityDto): Promise<User | undefined> {
        return this.readOneToOneRequiredProjection<User>(obj);
    }
    
    public async readOneToOneRequiredProjectionUserBaseProjection(obj: RelTestEntityDto): Promise<UserBaseProjection | undefined> {
        return this.readOneToOneRequiredProjection<UserBaseProjection>(obj, "baseProjection");
    }
    
    public async readOneToOneRequiredProjection<T extends Dto>(obj: RelTestEntityDto, projection?: string): Promise<T | undefined> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.oneToOneRequired);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return undefined; }
        if(!response.ok){ throw response; }
        
        const result = (await response.json()) as T;
        return apiHelper.injectIds(result);
    }
    
    public async setOneToOneRequired(returnType: RelTestEntity, child: User) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        // eslint-disable-next-line no-throw-literal
        if(!child._links) throw `Child has no _links: ${child.id}`;
        await this._requestAdapter.adaptAnyToOne(
            apiHelper.removeParamsFromNavigationHref(returnType._links.oneToOneRequired),
            child._links.self.href
        );
    }
  
    
}

export class SecuredEntityClient extends BaseClient<ApiClient, SecuredEntityNew, SecuredEntity> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/securedEntities", "securedEntities", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        
    }
  
    public static build(base: Partial<SecuredEntityNew> = {}): SecuredEntityNew {
        return {
            secretText: base.secretText !== undefined ? base.secretText : ""
        }
    }
  
    protected toPlainObj(obj: SecuredEntity): SecuredEntity {
        return {
            id: obj.id,
            secretText: obj.secretText,
            _links: obj._links
        };
    }
  
    public async readProjectionsSecuredEntityBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "secretText,ASC" | "secretText,DESC") : Promise<PagedItems<SecuredEntityBaseProjection>> {
        return this.readProjections<SecuredEntityBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionSecuredEntityBaseProjection(id: number): Promise<SecuredEntityBaseProjection| undefined> {
        return this.readProjection<SecuredEntityBaseProjection>(id, "baseProjection");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "secretText,ASC" | "secretText,DESC") : Promise<PagedItems<SecuredEntity>> {
        return await this.readProjections<SecuredEntity>(undefined, page, size, sort);
    }
  
    
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/securedEntities");
    }

  
    
  
    
}

export class UserClient extends BaseClient<ApiClient, UserNew, User> {

    constructor(apiClient: ApiClient, requestAdapter: RequestAdapter){
        super("/api/users", "users", apiClient, requestAdapter);
        this.readOne = this.readOne.bind(this);
        this.readProjection = this.readProjection.bind(this);
        this.readContactsProjection = this.readContactsProjection.bind(this);
    }
  
    public static build(base: Partial<UserNew> = {}): UserNew {
        return {
            name: base.name !== undefined ? base.name : "",
            contacts: base.contacts !== undefined ? base.contacts : []
        }
    }
  
    protected toPlainObj(obj: User): User {
        return {
            id: obj.id,
            name: obj.name,
            _links: obj._links
        };
    }
  
    public async readProjectionsUserBaseProjection(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "name,ASC" | "name,DESC") : Promise<PagedItems<UserBaseProjection>> {
        return this.readProjections<UserBaseProjection>("baseProjection", page, size, sort);
    }
            
    public async readProjectionUserBaseProjection(id: number): Promise<UserBaseProjection| undefined> {
        return this.readProjection<UserBaseProjection>(id, "baseProjection");
    }
    
    public async readAll(page?: number, size?: number, sort?: "id,ASC" | "id,DESC" | "name,ASC" | "name,DESC") : Promise<PagedItems<User>> {
        return await this.readProjections<User>(undefined, page, size, sort);
    }
  
    public async deleteFromContacts(returnType: User, childToDelete: Contact) {
        await this._requestAdapter.fetchAdapter.delete(`/api/users/${returnType.id}/contacts/${childToDelete.id}`);
    }
  
    public allowedMethods(): Promise<EntitySecurity> {
        return EntitySecurity.fetch(this._requestAdapter.fetchAdapter, "/api", "//api/users");
    }

  
    public async readContacts(obj: UserDto): Promise<Contact[]> {
        return this.readContactsProjection<Contact>(obj);
    }
    
    public async readContactsProjectionContactBaseProjection(obj: UserDto): Promise<ContactBaseProjection[]> {
        return this.readContactsProjection<ContactBaseProjection>(obj, "baseProjection");
    }
    
    
    
    public async readContactsProjectionContactFull(obj: UserDto): Promise<ContactFull[]> {
        return this.readContactsProjection<ContactFull>(obj, "full");
    }
    
    public async readContactsProjection<T extends Dto>(obj: UserDto, projection?: string): Promise<T[]> {
        const hasProjection = !!projection;
        let fullUrl = apiHelper.removeParamsFromNavigationHref(obj._links.contacts);
        fullUrl = hasProjection ? `${fullUrl}?projection=${projection}` : fullUrl;
    
        const response = await this._requestAdapter.fetchAdapter.get(fullUrl);
        if(response.status === 404) { return []; }
        if(!response.ok){ throw response; }
        return (((await response.json()) as ApiHateoasObjectBase<T[]>)._embedded.contacts).map(item => (apiHelper.injectIds(item)));
    }
    
    public async setContacts(returnType: User, children: Contact[]) {
        // eslint-disable-next-line no-throw-literal
        if(!returnType._links) throw `Parent has no _links: ${returnType.id}`;
        await this._requestAdapter.adaptAnyToMany(
            apiHelper.removeParamsFromNavigationHref(returnType._links.contacts),
            children.map(c => {
                // eslint-disable-next-line no-throw-literal
                if(!c._links) throw `Child has no _links: ${c.id}`;
                return c._links.self.href;
            })
        )
    }
    
    public async addToContacts(returnType: User, childToAdd: Contact) {
        await this._requestAdapter.addToObj(childToAdd, returnType, "contacts");
    }
  
    public async searchFindUserByName<T extends User>(name: string, projection?: string, sort?: "id,ASC" | "id,DESC" | "name,ASC" | "name,DESC"): Promise<T | undefined> {
        const parameters: {[key: string]: string | number | boolean | undefined} = {name};
            
        const url = stringHelper.appendParams("/api/users/search/findUserByName", parameters);
    
        const response = await this._requestAdapter.fetchAdapter.get(url);
        const responseObj = ((await response.json()) as T);
        
        return responseObj;
    }
    
    public async isSearchFindUserByNameAllowed(): Promise<boolean> {
        return isEndpointCallAllowed(this._requestAdapter.fetchAdapter, "//api", "GET", "//api/users/search/findUserByName");
    }
}